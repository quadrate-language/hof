/// Higher-Order Function combinators.
/// Combinators are functions that combine or apply other functions in useful patterns.
/// They enable functional programming without explicit temporary variables.

/// Apply a function to a value.
/// @param x i64 The input value
/// @param f ptr Function pointer (i64 -- i64)
/// @return r i64 Result of f(x)
/// @example 5 fn (x:i64 -- r:i64) { 2 * } hof::apply print nl  // 10
pub fn apply(x:i64 f:ptr -- r:i64) {
	-> f
	f call
}

/// Apply two functions to the same value.
/// @param x i64 The input value
/// @param f ptr First function pointer (i64 -- i64)
/// @param g ptr Second function pointer (i64 -- i64)
/// @return a i64 Result of f(x)
/// @return b i64 Result of g(x)
/// @example 5 fn (x:i64 -- r:i64) { 2 * } fn (x:i64 -- r:i64) { 3 + } hof::bi  // Stack: 10 8
pub fn bi(x:i64 f:ptr g:ptr -- a:i64 b:i64) {
	-> g
	-> f
	-> x
	x f call -> a
	x g call -> b
	a b
}

/// Apply three functions to the same value.
/// @param x i64 The input value
/// @param f ptr First function pointer (i64 -- i64)
/// @param g ptr Second function pointer (i64 -- i64)
/// @param h ptr Third function pointer (i64 -- i64)
/// @return a i64 Result of f(x)
/// @return b i64 Result of g(x)
/// @return c i64 Result of h(x)
/// @example 5 fn (x:i64 -- r:i64) { 1 + } fn (x:i64 -- r:i64) { 2 * } fn (x:i64 -- r:i64) { dup * } hof::tri  // Stack: 6 10 25
pub fn tri(x:i64 f:ptr g:ptr h:ptr -- a:i64 b:i64 c:i64) {
	-> h
	-> g
	-> f
	-> x
	x f call -> a
	x g call -> b
	x h call -> c
	a b c
}

/// Apply a function but keep the original value.
/// @param x i64 The input value
/// @param f ptr Function pointer (i64 -- i64)
/// @return r i64 Result of f(x)
/// @return x i64 Original value (preserved)
/// @example 5 fn (x:i64 -- r:i64) { 2 * } hof::keep  // Stack: 10 5
pub fn keep(x:i64 f:ptr -- r:i64 orig:i64) {
	-> f
	-> x
	x f call
	x
}

/// Apply a function to the second stack element, preserving the top.
/// @param x i64 Second element (will have f applied)
/// @param y i64 Top element (preserved)
/// @param f ptr Function pointer (i64 -- i64)
/// @return r i64 Result of f(x)
/// @return y i64 Original top value (preserved)
/// @example 10 20 fn (x:i64 -- r:i64) { 2 * } hof::dip  // Stack: 20 20
pub fn dip(x:i64 y:i64 f:ptr -- r:i64 top:i64) {
	-> f
	-> y
	f call
	y
}

/// Apply a function to two values separately.
/// @param x i64 First value
/// @param y i64 Second value
/// @param f ptr Function pointer (i64 -- i64)
/// @return a i64 Result of f(x)
/// @return b i64 Result of f(y)
/// @example 3 4 fn (x:i64 -- r:i64) { dup * } hof::both  // Stack: 9 16
pub fn both(x:i64 y:i64 f:ptr -- a:i64 b:i64) {
	-> f
	-> y
	-> x
	x f call -> a
	y f call -> b
	a b
}

/// Apply two functions to two values (first to first, second to second).
/// @param x i64 First value
/// @param y i64 Second value
/// @param f ptr Function for first value (i64 -- i64)
/// @param g ptr Function for second value (i64 -- i64)
/// @return a i64 Result of f(x)
/// @return b i64 Result of g(y)
/// @example 3 4 fn (x:i64 -- r:i64) { 1 + } fn (x:i64 -- r:i64) { 2 * } hof::bi_star  // Stack: 4 8
pub fn bi_star(x:i64 y:i64 f:ptr g:ptr -- a:i64 b:i64) {
	-> g
	-> f
	-> y
	-> x
	x f call -> a
	y g call -> b
	a b
}

/// Apply function only if condition is true, otherwise return value unchanged.
/// @param x i64 The input value
/// @param cond i64 Condition (0 = false, non-zero = true)
/// @param f ptr Function pointer (i64 -- i64)
/// @return r i64 Result of f(x) if cond is true, otherwise x
/// @example 5 1 fn (x:i64 -- r:i64) { 2 * } hof::when print nl  // 10
/// @example 5 0 fn (x:i64 -- r:i64) { 2 * } hof::when print nl  // 5
pub fn when(x:i64 cond:i64 f:ptr -- r:i64) {
	-> f
	-> cond
	cond 0 != if {
		f call
	}
}

/// Apply function only if condition is false, otherwise return value unchanged.
/// @param x i64 The input value
/// @param cond i64 Condition (0 = false, non-zero = true)
/// @param f ptr Function pointer (i64 -- i64)
/// @return r i64 Result of f(x) if cond is false, otherwise x
/// @example 5 0 fn (x:i64 -- r:i64) { 2 * } hof::unless print nl  // 10
/// @example 5 1 fn (x:i64 -- r:i64) { 2 * } hof::unless print nl  // 5
pub fn unless(x:i64 cond:i64 f:ptr -- r:i64) {
	-> f
	-> cond
	cond 0 == if {
		f call
	}
}

/// Apply function n times to an initial value.
/// @param x i64 Initial value
/// @param n i64 Number of times to apply
/// @param f ptr Function pointer (i64 -- i64)
/// @return r i64 Result after n applications
/// @example 2 4 fn (x:i64 -- r:i64) { dup * } hof::times print nl  // 65536 (2^16)
pub fn times(x:i64 n:i64 f:ptr -- r:i64) {
	-> f
	-> n
	0 n 1 for i {
		f call
	}
}

/// Compose two functions: compose(f, g)(x) = g(f(x)).
/// First f is applied, then g is applied to the result.
/// @param f ptr First function pointer (i64 -- i64)
/// @param g ptr Second function pointer (i64 -- i64)
/// @return fg ptr Composed function pointer (i64 -- i64)
/// @example fn (x:i64 -- r:i64) { 2 * } fn (x:i64 -- r:i64) { 1 + } hof::compose -> f  5 f call print nl  // 11
pub fn compose(f:ptr g:ptr -- fg:ptr) {
	-> g
	-> f
	fn (x:i64 -- r:i64) {
		-> x
		x f call g call
	}
}

/// Curry: create a new function with the first argument fixed.
/// @param x i64 The value to bind as first argument
/// @param f ptr Function pointer (i64 i64 -- i64)
/// @return curried ptr New function pointer (i64 -- i64)
/// @example 5 fn (x:i64 y:i64 -- r:i64) { + } hof::curry -> add5  10 add5 call print nl  // 15
pub fn curry(x:i64 f:ptr -- curried:ptr) {
	-> f
	-> x
	fn (y:i64 -- r:i64) {
		-> y
		x y f call
	}
}

/// Curry right: create a new function with the second argument fixed.
/// @param y i64 The value to bind as second argument
/// @param f ptr Function pointer (i64 i64 -- i64)
/// @return curried ptr New function pointer (i64 -- i64)
/// @example 2 fn (x:i64 y:i64 -- r:i64) { / } hof::curry_right -> half  10 half call print nl  // 5
pub fn curry_right(y:i64 f:ptr -- curried:ptr) {
	-> f
	-> y
	fn (x:i64 -- r:i64) {
		-> x
		x y f call
	}
}

/// Fold/reduce an array left-to-right with a binary function.
/// @param arr ptr Array pointer
/// @param count i64 Array length
/// @param init i64 Initial accumulator value
/// @param f ptr Binary function pointer (acc:i64 elem:i64 -- acc:i64)
/// @return result i64 Final accumulated value
/// @example arr count 0 fn (acc:i64 x:i64 -- r:i64) { + } hof::fold  // sum of array
pub fn fold(arr:ptr count:i64 init:i64 f:ptr -- result:i64) {
	-> f
	-> acc
	-> count
	-> arr
	0 count 1 for i {
		arr i nth acc swap f call -> acc
	}
	acc
}

/// Fold/reduce an array right-to-left with a binary function.
/// @param arr ptr Array pointer
/// @param count i64 Array length
/// @param init i64 Initial accumulator value
/// @param f ptr Binary function pointer (elem:i64 acc:i64 -- acc:i64)
/// @return result i64 Final accumulated value
/// @example arr count 0 fn (x:i64 acc:i64 -- r:i64) { + } hof::fold_right  // sum of array
pub fn fold_right(arr:ptr count:i64 init:i64 f:ptr -- result:i64) {
	-> f
	-> acc
	-> count
	-> arr
	count 1 - -1 -1 for i {
		arr i nth acc f call -> acc
	}
	acc
}

/// Map a function over an array, returning a new array.
/// @param arr ptr Input array pointer
/// @param count i64 Array length
/// @param f ptr Function pointer (i64 -- i64)
/// @return result ptr New array with mapped values
/// @return out_count i64 Array length (unchanged)
/// @example arr count fn (x:i64 -- r:i64) { 2 * } hof::map  // double each element
pub fn map(arr:ptr count:i64 f:ptr -- result:ptr out_count:i64) {
	-> f
	-> count
	-> arr
	count make<i64> -> out
	0 count 1 for i {
		arr i nth f call out swap append -> out
	}
	out count
}

/// Filter an array, keeping only elements that satisfy a predicate.
/// @param arr ptr Input array pointer
/// @param count i64 Array length
/// @param pred ptr Predicate function pointer (i64 -- bool:i64)
/// @return result ptr New array with filtered values
/// @return out_count i64 Length of filtered array
/// @example arr count fn (x:i64 -- r:i64) { 2 mod 0 == } hof::filter  // keep evens
pub fn filter(arr:ptr count:i64 pred:ptr -- result:ptr out_count:i64) {
	-> pred
	-> count
	-> arr
	0 make<i64> -> out
	0 -> out_count
	0 count 1 for i {
		arr i nth -> elem
		elem pred call if {
			out elem append -> out
			out_count 1 + -> out_count
		}
	}
	out out_count
}

/// Check if any element satisfies a predicate.
/// @param arr ptr Array pointer
/// @param count i64 Array length
/// @param pred ptr Predicate function pointer (i64 -- bool:i64)
/// @return result i64 1 if any element satisfies pred, 0 otherwise
/// @example arr count fn (x:i64 -- r:i64) { 0 > } hof::any  // any positive?
pub fn any(arr:ptr count:i64 pred:ptr -- result:i64) {
	-> pred
	-> count
	-> arr
	0 -> result
	0 count 1 for i {
		arr i nth pred call if {
			1 -> result
			break
		}
	}
	result
}

/// Check if all elements satisfy a predicate.
/// @param arr ptr Array pointer
/// @param count i64 Array length
/// @param pred ptr Predicate function pointer (i64 -- bool:i64)
/// @return result i64 1 if all elements satisfy pred, 0 otherwise
/// @example arr count fn (x:i64 -- r:i64) { 0 > } hof::all  // all positive?
pub fn all(arr:ptr count:i64 pred:ptr -- result:i64) {
	-> pred
	-> count
	-> arr
	1 -> result
	0 count 1 for i {
		arr i nth pred call not if {
			0 -> result
			break
		}
	}
	result
}

/// Find the first element satisfying a predicate.
/// @param arr ptr Array pointer
/// @param count i64 Array length
/// @param pred ptr Predicate function pointer (i64 -- bool:i64)
/// @return elem i64 The found element (or 0 if not found)
/// @return found i64 1 if found, 0 otherwise
/// @example arr count fn (x:i64 -- r:i64) { 10 > } hof::find  // first > 10
pub fn find(arr:ptr count:i64 pred:ptr -- elem:i64 found:i64) {
	-> pred
	-> count
	-> arr
	0 -> elem
	0 -> found
	0 count 1 for i {
		arr i nth -> x
		x pred call if {
			x -> elem
			1 -> found
			break
		}
	}
	elem found
}

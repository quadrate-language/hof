// Unit tests for the hof (higher-order functions) module
use hof
use testing

test "hof::apply" {
	5 fn (x:i64 -- r:i64) { 2 * } hof::apply 10 testing::assert_eq
	10 fn (x:i64 -- r:i64) { 3 + } hof::apply 13 testing::assert_eq
	7 fn (x:i64 -- r:i64) { dup * } hof::apply 49 testing::assert_eq
}

test "hof::bi" {
	5 fn (x:i64 -- r:i64) { 1 + } fn (x:i64 -- r:i64) { 2 * } hof::bi
	-> b -> a
	a 6 testing::assert_eq
	b 10 testing::assert_eq
}

test "hof::both" {
	3 4 fn (x:i64 -- r:i64) { 2 * } hof::both
	-> b -> a
	a 6 testing::assert_eq
	b 8 testing::assert_eq
}

test "hof::compose" {
	fn (x:i64 -- r:i64) { 1 + } fn (x:i64 -- r:i64) { 2 * } hof::compose -> f
	5 f hof::apply 12 testing::assert_eq  // (5 + 1) * 2 = 12
}

test "hof::dip" {
	3 4 fn ( -- ) { 10 + } hof::dip
	-> top -> below
	below 13 testing::assert_eq
	top 4 testing::assert_eq
}

test "hof::keep" {
	5 fn (x:i64 -- r:i64) { 2 * } hof::keep
	-> result -> kept
	kept 5 testing::assert_eq
	result 10 testing::assert_eq
}

test "hof::times" {
	0 5 fn ( -- ) { 1 + } hof::times 5 testing::assert_eq
	1 4 fn ( -- ) { 2 * } hof::times 16 testing::assert_eq
}

test "hof::when" {
	5 1 fn ( -- ) { 10 + } hof::when 15 testing::assert_eq
	5 0 fn ( -- ) { 10 + } hof::when 5 testing::assert_eq
}

test "hof::unless" {
	5 0 fn ( -- ) { 10 + } hof::unless 15 testing::assert_eq
	5 1 fn ( -- ) { 10 + } hof::unless 5 testing::assert_eq
}

test "hof::fold" {
	0 make<i64> 1 append 2 append 3 append 4 append 5 append -> arr
	arr 5 0 fn (acc:i64 x:i64 -- r:i64) { -> x -> acc acc x + } hof::fold 15 testing::assert_eq
	arr free
}

test "hof::tri" {
	10 fn (x:i64 -- r:i64) { 1 + } fn (x:i64 -- r:i64) { 2 * } fn (x:i64 -- r:i64) { 3 - } hof::tri
	-> c -> b -> a
	a 11 testing::assert_eq
	b 20 testing::assert_eq
	c 7 testing::assert_eq
}

test "hof::curry" {
	// curry: fix first argument
	5 fn (a:i64 b:i64 -- r:i64) { -> b -> a a b + } hof::curry -> add5
	10 add5 call 15 testing::assert_eq
	20 add5 call 25 testing::assert_eq
}

test "hof::curry_right" {
	// curry_right: fix second argument
	2 fn (a:i64 b:i64 -- r:i64) { -> b -> a a b / } hof::curry_right -> half
	10 half call 5 testing::assert_eq
	100 half call 50 testing::assert_eq
}

test "hof::bi_star" {
	// bi_star applies different functions to two values
	3 4 fn (x:i64 -- r:i64) { 1 + } fn (x:i64 -- r:i64) { 2 * } hof::bi_star
	-> b -> a
	a 4 testing::assert_eq   // 3 + 1 = 4
	b 8 testing::assert_eq   // 4 * 2 = 8
}

test "hof::fold_right" {
	// fold_right: fold from the right side
	0 make<i64> 1 append 2 append 3 append -> arr
	// Subtraction to show right-to-left: 1 - (2 - (3 - 0)) = 1 - (2 - 3) = 1 - (-1) = 2
	arr 3 0 fn (acc:i64 x:i64 -- r:i64) { -> x -> acc x acc - } hof::fold_right 2 testing::assert_eq
	arr free
}

test "hof::map" {
	// map: apply function to each element
	0 make<i64> 1 append 2 append 3 append -> arr
	arr 3 fn (x:i64 -- r:i64) { 2 * } hof::map -> count -> result
	count 3 testing::assert_eq
	result 0 nth 2 testing::assert_eq   // 1 * 2
	result 1 nth 4 testing::assert_eq   // 2 * 2
	result 2 nth 6 testing::assert_eq   // 3 * 2
	result free
	arr free
}

test "hof::filter" {
	// filter: keep elements matching predicate
	0 make<i64> 1 append 2 append 3 append 4 append 5 append -> arr
	arr 5 fn (x:i64 -- r:i64) { 2 % 0 == } hof::filter -> count -> result
	count 2 testing::assert_eq  // 2 and 4 are even
	result 0 nth 2 testing::assert_eq
	result 1 nth 4 testing::assert_eq
	result free
	arr free
}

test "hof::any" {
	// any: check if any element matches predicate
	0 make<i64> 1 append 3 append 5 append -> odds
	0 make<i64> 2 append 4 append 6 append -> evens

	// Check if any odd number is even (should be false)
	odds 3 fn (x:i64 -- r:i64) { 2 % 0 == } hof::any testing::assert_false

	// Check if any even number is even (should be true)
	evens 3 fn (x:i64 -- r:i64) { 2 % 0 == } hof::any testing::assert_true

	odds free
	evens free
}

test "hof::all" {
	// all: check if all elements match predicate
	0 make<i64> 2 append 4 append 6 append -> evens
	0 make<i64> 2 append 3 append 4 append -> mixed

	// Check if all are even
	evens 3 fn (x:i64 -- r:i64) { 2 % 0 == } hof::all testing::assert_true
	mixed 3 fn (x:i64 -- r:i64) { 2 % 0 == } hof::all testing::assert_false

	evens free
	mixed free
}

test "hof::find" {
	// find: find first element matching predicate
	0 make<i64> 1 append 2 append 3 append 4 append -> arr

	// Find first even number
	arr 4 fn (x:i64 -- r:i64) { 2 % 0 == } hof::find -> found -> elem
	found testing::assert_true
	elem 2 testing::assert_eq

	// Find number greater than 10 (not found)
	arr 4 fn (x:i64 -- r:i64) { 10 > } hof::find -> found -> elem
	found testing::assert_false

	arr free
}
